import requests
import paho.mqtt.client as mqtt
import json
import time
import os
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

# --- CONFIGURACI√ìN CR√çTICA ---
MQTT_BROKER = os.getenv("MQTT_HOST", "mosquitto")
MQTT_PORT = int(os.getenv("MQTT_PORT", 1883))
MQTT_TOPIC = "greendelivery/rubia/telemetry"

# --- CONFIGURACI√ìN DE RESILIENCIA (Cap. 5) ---
API_INGEST_URL = os.getenv("API_INGEST_URL", "http://alonso-api:8000/ingest")
DISCORD_WEBHOOK_URL = os.getenv("DISCORD_WEBHOOK_URL") # Nueva variable
MAX_RETRIES = 5

# --- Umbrales del Negocio (Cap. 3) ---
TEMP_UMBRAL = 8.0  # Regla de negocio: SI temperatura > 8.0 ¬∞C
G_FORCE_UMBRAL = 2.5 # Regla ML sencilla: SI fuerza_g > 2.5 G
CONSECUTIVE_EVENTS = 3 # L√≥gica Stateful: Sostenida durante N eventos

# Diccionario Global para mantener la memoria del estado de cada env√≠o
# Estado: {'consecutive': int, 'is_alerting': bool}
package_state = {}


# --- FUNCIONES DE ACCI√ìN (Cap. 4) ---

def send_discord_alert(data, reason):
    """Env√≠a un mensaje de alerta a Discord usando el Webhook."""
    if not DISCORD_WEBHOOK_URL:
        print("‚ùå ERROR: La URL de Discord no est√° configurada. No se pudo enviar la alerta.")
        return

    # Construcci√≥n del payload JSON para Discord (Embed)
    payload = {
        "content": "@here üö® **ALERTA CR√çTICA SOSTENIDA** üö®",
        "embeds": [{
            "title": f"Env√≠o {data.get('id_paquete')} - Incidente Detectado",
            "description": f"Raz√≥n: **{reason}**.\nCondici√≥n an√≥mala mantenida por {CONSECUTIVE_EVENTS} eventos.",
            "color": 16711680, # Color Rojo
            "fields": [
                {"name": "Temperatura", "value": f"{data.get('temperatura', 'N/A')} ¬∞C", "inline": True},
                {"name": "Fuerza G", "value": f"{data.get('fuerza_g_ejez', 'N/A')} G", "inline": True},
                {"name": "Timestamp", "value": data.get('timestamp', 'N/A'), "inline": False}
            ]
        }]
    }

    try:
        response = requests.post(DISCORD_WEBHOOK_URL, json=payload)
        response.raise_for_status()
        print(f"‚úÖ Notificaci√≥n enviada a Discord para {data.get('id_paquete')}.")
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error al enviar la alerta a Discord: {e}")


# --- FUNCI√ìN DE RESILIENCIA (Cap. 5) ---

def send_to_ingest_api(data, max_retries=MAX_RETRIES):
    """Implementa la Resiliencia: Env√≠a datos a la API con reintentos y backoff."""
    retries = 0
    while retries < max_retries:
        try:
            # Petici√≥n POST a la API de Alonso
            response = requests.post(API_INGEST_URL, json=data, timeout=5)
            response.raise_for_status()

            print(f"üü¢ √âxito: Dato {data.get('id_paquete')} insertado correctamente.")
            return

        except requests.exceptions.RequestException as e:
            retries += 1
            # A√±adido log para la Boss Fight
            print(f"‚ùå Fallo de API/Red (Intento {retries}/{max_retries}): {e} [REINTENTANDO]")

            if retries < max_retries:
                # Retardo Exponencial (Backoff)
                wait_time = 2 ** retries
                time.sleep(wait_time)
            else:
                # Fallo cr√≠tico y p√©rdida de dato (solo en este prototipo)
                print(f"‚ùå‚ùå FALLO CR√çTICO: Se agotaron los reintentos. Dato {data.get('id_paquete')} **PERDIDO**.")
                return 


# --- L√ìGICA DEL CEREBRO (Cap. 3) ---

def process_telemetry(data):
    """Aplica la l√≥gica de estado y umbrales a cada dato."""
    global package_state

    temp = data.get('temperatura_c', 99.9) # Corregido: asumimos 'temperatura_c' de DDL
    g_force = data.get('fuerza_g_ejez', 0.0) # A√±adido G-Force
    package_id = data.get('id_paquete', 'N/A')

    # 1. Validaci√≥n inicial del estado
    if package_id not in package_state:
        package_state[package_id] = {'consecutive': 0, 'is_alerting': False}

    # 2. ¬øEl evento actual es malo? (Regla de negocio + ML sencillo)
    is_temp_alert = temp > TEMP_UMBRAL
    is_g_force_alert = g_force > G_FORCE_UMBRAL
    is_alert_event = is_temp_alert or is_g_force_alert
    
    # Raz√≥n de la alerta para el mensaje de Discord
    reason = ""
    if is_temp_alert and is_g_force_alert:
        reason = "Temperatura y Posible Impacto"
    elif is_temp_alert:
        reason = "Temperatura Excedida"
    elif is_g_force_alert:
        reason = "Posible Impacto Sostenido"


    if is_alert_event:
        package_state[package_id]['consecutive'] += 1

        if package_state[package_id]['consecutive'] >= CONSECUTIVE_EVENTS:
            
            # Solo enviar alerta a Discord si no se ha alertado ya (throttling)
            if not package_state[package_id]['is_alerting']:
                # ALERTA CR√çTICA SOSTENIDA
                print(f"üö®üö® ALERTA CR√çTICA SOSTENIDA: {package_id} - Raz√≥n: {reason}. Enviando a Discord.")
                send_discord_alert(data, reason)
                package_state[package_id]['is_alerting'] = True # Bloqueamos futuras alertas hasta que se normalice
        
        else:
            # Pico temporal
            print(f"üå°Ô∏è Advertencia: Pico temporal ({reason}). Contador: {package_state[package_id]['consecutive']}/{CONSECUTIVE_EVENTS}")

    else:
        # Dato bueno, reseteamos el contador y el estado de alerta
        if package_state[package_id]['consecutive'] > 0:
            print(f"üü¢ Reseteando alerta de {package_id}. Volvi√≥ a la normalidad.")
        
        package_state[package_id]['consecutive'] = 0
        package_state[package_id]['is_alerting'] = False # Permitimos que se dispare la alerta de nuevo


    # ‚¨áÔ∏è TAREA: Llamar a la funci√≥n de env√≠o resiliente para persistir el dato
    send_to_ingest_api(data)


# --- FUNCIONES MQTT y INICIO DEL SERVICIO (Sin cambios) ---

def on_connect(client, userdata, flags, rc):
    """Callback que se ejecuta al conectar con el Broker."""
    if rc == 0:
        print("Conexi√≥n MQTT exitosa. Suscribi√©ndose...")
        client.subscribe(MQTT_TOPIC)
    else:
        print(f"Fallo en la conexi√≥n MQTT. C√≥digo: {rc}")

def on_message(client, userdata, msg):
    """Callback que se ejecuta al recibir un mensaje."""
    try:
        data = json.loads(msg.payload.decode('utf-8'))
        # Se asume que el payload tiene 'temperatura_c', 'fuerza_g_ejez', 'id_paquete', 'timestamp'
        process_telemetry(data)
    except json.JSONDecodeError:
        print("Error: Mensaje JSON inv√°lido.")
    except Exception as e:
        print(f"Error al procesar mensaje: {e}")


if __name__ == "__main__":
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message

    try:
        print(f"Procesador: Intentando conectar a {MQTT_BROKER}:{MQTT_PORT}")
        client.connect(MQTT_BROKER, MQTT_PORT, 60)
        client.loop_forever()
    except Exception as e:
        print(f"Error fatal de conexi√≥n: {e}")
